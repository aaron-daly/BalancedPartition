# Haskell Balanced Partition

Write a Haskell program that calculates a balanced partition of N items, stored in an array, where each item has a value between 0 and K such that the difference between the sum of the values of first partition, S1, and the sum of the values of the second partiton, S2, is minimised. Each partition does not have to have the same number of elements.  For example, given the array [1,2,3,4,5], the balanced partitions could be [1,3,4] and [2,5], or [1,2,4] and [3,5], or [1,2,5] and [3,4].  One classical way to solve this is to use dynamic programming. For dynamic programming to be efficient you should avoid recalculating intermediate results. This can be tricky in a functional language as it does not store state information. The solution is data memoisation. Intermediate results are stored is a data structure when they are initially calculated and then simply retrived when needed.  Here is an example of data memoisation in calculating a Fibonacci number.  import Data.Array  fibonacci :: Integer -> Integer fibonacci n = memo!n where   memo = array (0, n) [ (i, fib i) | i &lt;- [0..n] ]   fib 0 = 0   fib 1 = 1   fib i = memo!(i-1) + memo!(i-2) This example uses the Array module. Since Haskell is a lazy programming language it only calculates a function when it is needed.  Implement a solution to the balanced partition in Haskell.  Submission:  This is an individual assignment. All the source code for the application, a Word document describing the design of your application and a declaration that this is solely your own work (except elements that are explicitly attributed to another source and will not contribute to your mark) must be emailed to David.Sinclair(at)computing.dcu.ie by 1000, Monday 14th December 2015.  Please click here to review the School's policy on plagarism.  Submissions without the declaration will not be assessed. This assignment carries 15 marks and late submissions will be penalised 1.5 marks for each 24 hours the assignment is overdue.
